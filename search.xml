<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Comparator]]></title>
    <url>%2F2019%2F03%2F18%2FComparator%2F</url>
    <content type="text"><![CDATA[比较Student的顺序 priority:CGPA &gt; name &gt; ID ###方法一 实现Comparator借口，重载compare函数，剩下的你懂的 1234567891011121314class StudentComparator implements Comparator&lt;Student&gt; &#123; @Override public int compare(Student o1, Student o2) &#123; if (o1.getCGPA() == o2.getCGPA()) &#123; if(o1.getName().equals(o2.getName())) &#123; return Integer.compare(o2.getID(), o1.getID()); &#125; else &#123; return o1.getName().compareTo(o2.getName()); &#125; &#125; return Double.compare(o2.getCGPA(), o1.getCGPA()); &#125;&#125;PriorityQueue&lt;Student&gt; queue = new PriorityQueue&lt;&gt;(studentComparator); ###方法二,肥肠推荐该方法，很简便Comparator&lt;&gt;的简便实现方法 12345Comparator&lt;Student&gt; studentComparator = Comparator.comparing(Student::getCGPA).reversed() .thenComparing(Student::getName) .thenComparing(Student::getID); PriorityQueue&lt;Student&gt; queue = new PriorityQueue&lt;&gt;(studentComparator);]]></content>
      <tags>
        <tag>hackerrank</tag>
        <tag>Data Structrue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet&HashMap]]></title>
    <url>%2F2019%2F03%2F18%2FHashSet-HashMap%2F</url>
    <content type="text"><![CDATA[Java Dequeue In this problem, you are given integers. You need to find the maximum number of unique integers among all the possible contiguous subarrays of size . ###HashSet O(mn) HashSet维护Dequeue大小以内独特元素的个数，Dequeue每次吃一个元素就往HashSet里面补充该元素（根据集合的性质，重复元素不重复计数），当Dequeue元素数等于m时，Dequeue该吐出元素了（再吃一个元素就大于m惹），若吐出的元素不存在于Dequeue，则该元素也不应当存在于HashSet中，故此时要从HashSet中取出该元素 Dequeue不断吃元素，当Dequeue元素等于m时应吐出一个元素。 HashSet维护Dequeue内元素独特元素个数。 1234567891011121314151617181920212223242526import java.util.*;public class test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;(); HashSet&lt;Integer&gt; s = new HashSet&lt;&gt;(); int n = in.nextInt(); int m = in.nextInt(); int max = 0; for (int i = 0; i &lt; n; i++) &#123; int num = in.nextInt(); d.add(num); s.add(num); if( d.size() == m )&#123; max = s.size() &gt; max ? s.size() : max; int tmp = d.remove(); if( !d.contains(tmp) ) s.remove(tmp); &#125; &#125; System.out.println(max); in.close(); &#125;&#125; ###HashMap O(n) HashMap不同于HashSet的是HashMap有&lt;K,V&gt;键-值对 Dequeue不断吃元素，当Dequeue元素大于m时，该吐出一个元素。 HashMap维护的是Dequeue中每一个元素的个数。 上述两个方法本人认为使用HashSet更为巧妙 123456789101112131415161718192021222324252627282930import java.util.*;public class test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); Deque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;(); HashMap&lt;Integer,Integer&gt; hashmap = new HashMap&lt;Integer,Integer&gt;(); int n = in.nextInt(); int m = in.nextInt(); int ans = 0,distinct = 0; for (int i = 0; i &lt; n; i++) &#123; int num = in.nextInt(); deque.addLast(num); if( hashmap.get(num) == null ) hashmap.put(num,0); hashmap.put(num,hashmap.get(num) + 1); if( hashmap.get(num) == 1 ) distinct++; if( deque.size() == m + 1 )&#123; int _out = deque.removeFirst(); hashmap.put(_out,hashmap.get(_out) - 1); if( hashmap.get(_out) == 0 ) distinct--; &#125; if ( deque.size() == m ) ans = distinct &gt; ans ? distinct: ans; &#125; System.out.println( ans ); in.close(); &#125;&#125;]]></content>
      <tags>
        <tag>hackerrank</tag>
        <tag>java</tag>
        <tag>data structrue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序和]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[最大子序和 1.分治 分而治之，分数组为左半段与右半段，母数组的最大子序，可能藏在三个位置： 左半段，递归 右半段，递归 横跨左右半段分界点的一段，从分界点到左端点最大值+从分界点到右端点最大值 左端点为l，右端点为r，中点center = (l+r)/2，左半部分[l,center],右半部分[center+1,r]。 递归基：l==r，返回单点值。 T(N) = T(N/2) + O(N) — (1) T(1) = O(1) — (2) 由(1)、(2)式推出T(N) = O(NLogN) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return maxSubSum(nums,0,nums.size() - 1); &#125; int maxSubSum( vector&lt;int&gt;&amp; nums, int l, int r )&#123; int leftmax,rightmax,lefthalf,lefthalfmax,righthalf,righthalfmax,center; if( l == r )&#123; return nums[l]; &#125; center = ( l + r ) / 2; leftmax = maxSubSum(nums,l,center); rightmax = maxSubSum(nums,center + 1, r); lefthalf = 0; lefthalfmax = INT_MIN; for( int i = center; i &gt;= l; i-- )&#123; lefthalf += nums[i]; lefthalfmax = lefthalf &gt; lefthalfmax ? lefthalf : lefthalfmax; &#125; righthalf = 0; righthalfmax = INT_MIN; for( int i = center + 1; i &lt;= r; i++ )&#123; righthalf += nums[i]; righthalfmax = righthalf &gt; righthalfmax ? righthalf : righthalfmax; &#125; return MAX(leftmax,rightmax,lefthalfmax+righthalfmax); &#125; int MAX(int a,int b,int c)&#123; return max(max(a,b),max(b,c)); &#125;&#125;; 2.DP dp[i]:dp[0,i]为止最大子序和 状态转移方程 dp[i] = max{dp[i-1]+nums[i],nums[i]} 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size()); int ans = dp[0] = nums[0]; for( int i = 1; i &lt; nums.size(); i++ )&#123; dp[i] = max(nums[i],dp[i-1] + nums[i]); ans = max(dp[i],ans); &#125; return ans; &#125; &#125;;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIY慕斯]]></title>
    <url>%2F2019%2F03%2F02%2FDIY%E6%85%95%E6%96%AF%2F</url>
    <content type="text"><![CDATA[“爷爷，慕斯蛋糕好好吃啊”]]></content>
  </entry>
  <entry>
    <title><![CDATA[生成括号]]></title>
    <url>%2F2019%2F03%2F01%2F%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[生成括号 合法的括号组合必然是”(“数量与”)”数量相等，因此当一个”(“生成时必然有一个”)”生成。 想象手上有一把”(“但是却没有”)”，在地上放置一个”(“，则手中”叮”一声多出一个”)”，你的任务就是把手里的”(“”)”像牌一样打完放在地上。 设n为”(“数量，m为”)”数量。 当n == 0 &amp;&amp; m == 0 时为递归基。 设置初值n = N,m = 0。 放置一个”(“,n-=1,m+=1。 放置一个”)”,m-=1。 123456789101112131415class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ans; addingp(ans,&quot;&quot;,n,0); return ans; &#125; void addingp(vector&lt;string&gt; &amp;v, string str, int n, int m)&#123; if( n == 0 &amp;&amp; m == 0 )&#123; v.push_back(str); &#125; if( m &gt; 0 ) addingp(v,str+&quot;)&quot;,n,m-1); if( n &gt; 0 ) addingp(v,str+&quot;(&quot;,n-1,m+1); &#125;&#125;;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[G82]]></title>
    <url>%2F2018%2F08%2F08%2FG82%2F</url>
    <content type="text"><![CDATA[香 情郎 眼泛光 话里有浪 蹙眉似锋芒 怀抱浸润如洋 我不取天边月光 只做你俗世的姑娘 愿听你扯一辈子的谎 双腿间潺潺流水因你荡 日复一日巫山云雨淋漓畅 年复一年鱼水之欢胴体交往 骂你一句孩子还没睡呢臭流氓 跟上天感谢一列叫G82的动车厢]]></content>
  </entry>
</search>
