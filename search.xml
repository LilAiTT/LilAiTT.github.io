<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最大子序和]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[最大子序和 1.分治 分而治之，分数组为左半段与右半段，母数组的最大子序，可能藏在三个位置： 左半段，递归 右半段，递归 横跨左右半段分界点的一段，从分界点到左端点最大值+从分界点到右端点最大值 左端点为l，右端点为r，中点center = (l+r)/2，左半部分[l,center],右半部分[center+1,r]。 递归基：l==r，返回单点值。 T(N) = T(N/2) + O(N) — (1) T(1) = O(1) — (2) 由(1)、(2)式推出T(N) = O(NLogN) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return maxSubSum(nums,0,nums.size() - 1); &#125; int maxSubSum( vector&lt;int&gt;&amp; nums, int l, int r )&#123; int leftmax,rightmax,lefthalf,lefthalfmax,righthalf,righthalfmax,center; if( l == r )&#123; return nums[l]; &#125; center = ( l + r ) / 2; leftmax = maxSubSum(nums,l,center); rightmax = maxSubSum(nums,center + 1, r); lefthalf = 0; lefthalfmax = INT_MIN; for( int i = center; i &gt;= l; i-- )&#123; lefthalf += nums[i]; lefthalfmax = lefthalf &gt; lefthalfmax ? lefthalf : lefthalfmax; &#125; righthalf = 0; righthalfmax = INT_MIN; for( int i = center + 1; i &lt;= r; i++ )&#123; righthalf += nums[i]; righthalfmax = righthalf &gt; righthalfmax ? righthalf : righthalfmax; &#125; return MAX(leftmax,rightmax,lefthalfmax+righthalfmax); &#125; int MAX(int a,int b,int c)&#123; return max(max(a,b),max(b,c)); &#125;&#125;; 2.DP dp[i]:dp[0,i]为止最大子序和 状态转移方程 dp[i] = max{dp[i-1]+nums[i],nums[i]} 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size()); int ans = dp[0] = nums[0]; for( int i = 1; i &lt; nums.size(); i++ )&#123; dp[i] = max(nums[i],dp[i-1] + nums[i]); ans = max(dp[i],ans); &#125; return ans; &#125; &#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[生成括号]]></title>
    <url>%2F2019%2F03%2F01%2F%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[生成括号 合法的括号组合必然是”(“数量与”)”数量相等，因此当一个”(“生成时必然有一个”)”生成。 想象手上有一把”(“但是却没有”)”，在地上放置一个”(“，则手中”叮”一声多出一个”)”，你的任务就是把手里的”(“”)”像牌一样打完放在地上。 设n为”(“数量，m为”)”数量。 当n == 0 &amp;&amp; m == 0 时为递归基。 设置初值n = N,m = 0。 放置一个”(“,n-=1,m+=1。 放置一个”)”,m-=1。 123456789101112131415class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ans; addingp(ans,&quot;&quot;,n,0); return ans; &#125; void addingp(vector&lt;string&gt; &amp;v, string str, int n, int m)&#123; if( n == 0 &amp;&amp; m == 0 )&#123; v.push_back(str); &#125; if( m &gt; 0 ) addingp(v,str+&quot;)&quot;,n,m-1); if( n &gt; 0 ) addingp(v,str+&quot;(&quot;,n-1,m+1); &#125;&#125;;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[G82]]></title>
    <url>%2F2018%2F08%2F08%2FG82%2F</url>
    <content type="text"><![CDATA[香 情郎 眼泛光 话里有浪 蹙眉似锋芒 怀抱浸润如洋 我不取天边月光 只做你俗世的姑娘 愿听你扯一辈子的谎 双腿间潺潺流水因你荡 日复一日巫山云雨淋漓畅 年复一年鱼水之欢胴体交往 骂你一句孩子还没睡呢臭流氓 跟上天感谢一列叫G82的动车厢]]></content>
  </entry>
</search>
